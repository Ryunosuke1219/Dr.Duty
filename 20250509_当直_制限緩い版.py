# -*- coding: utf-8 -*-
"""20250509 当直 制限緩い版.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OeywIHF70fVlZyWgOpd9GLqqOma8yG7l
"""

!pip -q install pandas openpyxl ortools python-dateutil

import pandas as pd, re, datetime, random
from collections import defaultdict
from ortools.sat.python import cp_model
from google.colab import files
import openpyxl
from openpyxl.styles import Alignment, Border, Side, PatternFill, Font
from openpyxl.utils import get_column_letter

# =========================
# 1) CSV アップロード
# =========================
uploaded = files.upload()
csv_path = next(iter(uploaded))

# =========================
# 2) 基本データ読み込み
# =========================
df_raw = pd.read_csv(csv_path, encoding='cp932')
doctors   = df_raw['Name'].tolist()
group_map = df_raw.set_index('Name')['Group'].to_dict()
avail_df  = 1 - df_raw.drop(columns=['Group','Name'])

# ---- シフト列ユーティリティ -------------------------
def shift_sort_key(col):
    day = int(re.match(r'(\d+)', col).group(1))
    sub = int(re.search(r'-(\d)', col).group(1)) if '-' in col else 0  # 0=通常 1=-1 2=-2
    return (day, sub)

shift_cols = sorted(avail_df.columns, key=shift_sort_key)

"""月は都度変更"""

# 月を推定（今回は 2025-06 固定）
YEAR, MONTH = 2025, 5
def to_date(day): return datetime.date(YEAR, MONTH, day)

# ---- 各シフト属性 ------------------
shift_day   = {c: int(re.match(r'(\d+)', c).group(1)) for c in shift_cols}
shift_sub   = {c: int(re.search(r'-(\d)', c).group(1)) if '-' in c else 0 for c in shift_cols}
shift_week  = {c: to_date(shift_day[c]).isocalendar().week for c in shift_cols}  # ISO 週
shift_kind  = {c: 'holiday_double' if shift_sub[c]==1 else 'single' for c in shift_cols}

"""どうしてもシフト組めなそうなら3に緩和"""

SPACE = 4  # 連続勤務間隔

# =========================
# 3) 割付アルゴリズム
# =========================
duty, oncall = defaultdict(dict), {}
last_work = {d:-10 for d in doctors}
duty_cnt, oncall_cnt = defaultdict(int), defaultdict(int)
weekly_cnt   = defaultdict(lambda: defaultdict(int))  # weekly_cnt[doc][week]
holiday1_cnt = defaultdict(int)                       # -1 Duty 回数

def can_work(doc, col):
    return (avail_df.loc[df_raw['Name']==doc, col].iat[0]==1 and
            shift_day[col]-last_work[doc]>=SPACE and
            weekly_cnt[doc][shift_week[col]]==0 and
            (holiday1_cnt[doc] < 1 if shift_sub[col]==1 else True))

g1 = [d for d in doctors if group_map[d]==1]
g0 = [d for d in doctors if group_map[d]==0]
hd = [c for c in shift_cols if shift_sub[c]==1]  # -1
sg = [c for c in shift_cols if shift_sub[c]!=1]

# --- Group1 Duty 2 回固定 ---
random.shuffle(g1)
for doc in g1:
    for colset in (hd, sg):
        for col in random.sample(colset, len(colset)):
            if 'G1' in duty[col].values(): continue
            if can_work(doc,col):
                duty[col][doc]='G1'
                duty_cnt[doc]+=1
                last_work[doc]=shift_day[col]
                weekly_cnt[doc][shift_week[col]]=1
                if shift_sub[col]==1: holiday1_cnt[doc]+=1
                if duty_cnt[doc]==2: break
        if duty_cnt[doc]==2: break

# --- Group0 Duty 1〜2 回 ---
random.shuffle(g0)
for doc in g0:  # 1 回目
    if duty_cnt[doc]>0: continue
    for col in shift_cols:
        need = (shift_sub[col]==1 and 'G0' not in duty[col].values()) or \
               (shift_sub[col]!=1 and not duty[col])
        if need and can_work(doc,col):
            duty[col][doc]='G0'; duty_cnt[doc]+=1; last_work[doc]=shift_day[col]
            weekly_cnt[doc][shift_week[col]]=1
            if shift_sub[col]==1: holiday1_cnt[doc]+=1
            break

for col in shift_cols:  # 2 回目
    if (shift_sub[col]==1 and 'G0' not in duty[col].values()) or \
       (shift_sub[col]!=1 and not duty[col]):
        cands=[d for d in g0 if duty_cnt[d]<2 and can_work(d,col)]
        if cands:
            doc=random.choice(cands)
            duty[col][doc]='G0'; duty_cnt[doc]+=1; last_work[doc]=shift_day[col]
            weekly_cnt[doc][shift_week[col]]=1
            if shift_sub[col]==1: holiday1_cnt[doc]+=1

# --- on-call (G0) : Duty が G1 の single 列に必ず付与 ---
for col in sg:
    if 'G1' in duty[col].values():

        # ① 標準条件 ─ 勤務可 (0) & 4 日間隔クリア
        cands = [
            d for d in g0
            if d not in duty[col]                                       # その日 Duty ではない
            and avail_df.loc[df_raw['Name'] == d, col].iat[0] == 1      # 勤務可(0)
            and shift_day[col] - last_work[d] >= SPACE                  # 4 日間隔
        ]

        # ② 候補ゼロなら 4日間隔だけ緩和（勤務可フラグは堅持）
        if not cands:
            cands = [
                d for d in g0
                if d not in duty[col]
                and avail_df.loc[df_raw['Name'] == d, col].iat[0] == 1  # 勤務可(0)
            ]

        # ③ まだゼロなら警告を出して空欄に
        if not cands:
            warnings.append(f"[ONCALL-MISSING] {col} に割当候補なし")
            continue

        # --- 確定 ---
        doc = random.choice(cands)
        oncall[col]   = doc
        oncall_cnt[doc] += 1
        last_work[doc] = shift_day[col]

# =========================
# 4) DataFrame 作成
# =========================
rows=[]
for col in shift_cols:
    rows.append({'Shift':col,
                 'Duty_G0':', '.join([d for d,g in duty[col].items() if g=='G0']),
                 'Duty_G1':', '.join([d for d,g in duty[col].items() if g=='G1']),
                 'Oncall_G0': oncall.get(col,'')})
schedule_df = pd.DataFrame(rows)

summary_df = pd.DataFrame({
    'Group':[group_map[d] for d in doctors],
    'Duty':[duty_cnt[d] for d in doctors],
    'Oncall':[oncall_cnt[d] for d in doctors]
}, index=doctors)
summary_df['Total']=summary_df['Duty']+summary_df['Oncall']

# =========================
# 5) カレンダーシート
# =========================
def build_calendar_df():
    cal=[['' for _ in range(7)] for _ in range(6)]
    first_weekday = to_date(1).weekday()  # 0=Mon
    for col in shift_cols:
        day = shift_day[col]
        date = to_date(day)
        row = (day + first_weekday -1)//7
        col_idx = (date.weekday()+1)%7  # Sun=0
        duty_info = f"D0:{', '.join([d for d,g in duty[col].items() if g=='G0'])}\n" \
                    f"D1:{', '.join([d for d,g in duty[col].items() if g=='G1'])}"
        if oncall.get(col):
            duty_info += f"\nOC:{oncall[col]}"
        cal[row][col_idx] = f"{day}\n{duty_info}"
    return pd.DataFrame(cal, columns=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'])

calendar_df = build_calendar_df()

# =========================
# 6) 元 CSV に Duty=3 / on-call=4 を書き込み
# =========================
df_annot = df_raw.copy()
warnings = []

# Duty → 3
for _, row in schedule_df.iterrows():
    for name in row['Duty_G0'].split(', ') + row['Duty_G1'].split(', '):
        if name:
            if df_annot.loc[df_annot['Name']==name, row['Shift']].iat[0] != 0:
                warnings.append(f"[DUTY] {name} – {row['Shift']} は元が 0 でない")
            df_annot.loc[df_annot['Name']==name, row['Shift']] = 3

# on-call → 4
for _, row in schedule_df.iterrows():
    if row['Oncall_G0']:
        name = row['Oncall_G0']
        if df_annot.loc[df_annot['Name']==name, row['Shift']].iat[0] != 0:
            warnings.append(f"[ONCALL] {name} – {row['Shift']} は元が 0 でない")
        df_annot.loc[df_annot['Name']==name, row['Shift']] = 4

# CSV 出力
annot_path = 'availability_with_assignments.csv'
df_annot.to_csv(annot_path, index=False, encoding='cp932')

# =========================
# 7) Excel 出力も（同名で上書き）
# =========================
excel_path = 'schedule_with_calendar.xlsx'
with pd.ExcelWriter(excel_path) as w:
    schedule_df.to_excel(w,index=False,sheet_name='Schedule')
    summary_df.to_excel(w,            sheet_name='Summary')
    calendar_df.to_excel(w,index=False,sheet_name='Calendar')

# =========================
# 8) ダウンロード & 上書きチェック
# =========================
if warnings:
    print("⚠️  上書き警告あり：")
    for wmsg in warnings:
        print("  ", wmsg)
else:
    print("✅  すべて元が 0 のセルに書き込みました。")

files.download(excel_path)
files.download(annot_path)

import pandas as pd, openpyxl, datetime, re
from openpyxl.styles import Alignment, Border, Side, PatternFill, Font
from openpyxl.utils import get_column_letter
from collections import defaultdict
from google.colab import files

# ======================================================
# 1) 割付結果 Excel (Schedule シート) をアップロード
# ======================================================
uploaded = files.upload()               # schedule_with_calendar.xlsx を選択
source_excel = next(iter(uploaded))
schedule_df = pd.read_excel(source_excel, sheet_name="Schedule").fillna('')

# ======================================================
# 2) 年月を手入力 or 推定
# ======================================================
YEAR, MONTH = 2025, 6
def to_date(day): return datetime.date(YEAR, MONTH, day)

# ======================================================
# 3) 日本の祝日（簡易）
# ======================================================
jp_holidays_2025 = {
    datetime.date(2025,5,3), datetime.date(2025,5,4),
    datetime.date(2025,5,5), datetime.date(2025,5,6),
}

# ======================================================
# 4) day_info 構築
# ======================================================
day_info = defaultdict(lambda: {"日直":"", "当直":"", "OC":""})

for _, row in schedule_df.iterrows():
    # 日付・サブ番号取得
    day   = int(re.match(r'(\d+)', row["Shift"]).group(1))
    sub   = int(re.search(r'-(\d)', row["Shift"]).group(1)) if '-' in row["Shift"] else 0
    # Duty 名をまとめて '/' で結合
    names = "/".join([n for n in [row["Duty_G0"], row["Duty_G1"]] if n])
    if sub == 1:              # -1 → 日直
        day_info[day]["日直"] = names
    else:                     # -2 または通常 → 当直
        day_info[day]["当直"] = names
        if row["Oncall_G0"]:
            day_info[day]["OC"] = row["Oncall_G0"]

# ======================================================
# 5) Excel カレンダー作成
# ======================================================
wb = openpyxl.Workbook()
ws = wb.active
ws.title = "Calendar"

# --- Styles ---
thin   = Side(style="thin", color="000000")
border = Border(top=thin, left=thin, right=thin, bottom=thin)
center = Alignment(horizontal="center", vertical="center", wrap_text=True)
hdr_fill  = PatternFill("solid", fgColor="DDDDDD")
hdr_font  = Font(bold=True)
red_font  = Font(color="FF0000")
blue_font = Font(color="0000FF")

# --- タイトル ---
ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=7)
ws.cell(1,1, f"{YEAR}年{MONTH}月").alignment=center
ws.cell(1,1).font=Font(bold=True,size=14)

# --- 曜日ヘッダ ---
week = ["日","月","火","水","木","金","土"]
for col,wd in enumerate(week,1):
    c=ws.cell(2,col,wd); c.alignment=center; c.font=hdr_font; c.fill=hdr_fill; c.border=border
    ws.column_dimensions[get_column_letter(col)].width=22
for r in range(3,10): ws.row_dimensions[r].height=48

# --- カレンダー本体 ---
first_wd = to_date(1).weekday()          # Mon=0
col      = (first_wd+1)%7 + 1           # Sun=1
row, day = 3, 1
while True:
    try: date = to_date(day)
    except ValueError: break

    info = day_info[day]
    lines = []
    if info["日直"]:
        lines.append(f"日直 {info['日直']}")
    if info["当直"]:
        line = f"当直 {info['当直']}"
        if info["OC"]:
            line += f"/OC:{info['OC']}"
        lines.append(line)
    text = str(day) if not lines else f"{day}\n" + "\n".join(lines)

    cell = ws.cell(row,col,text); cell.alignment=center; cell.border=border
    if date in jp_holidays_2025 or date.weekday()==6:
        cell.font = red_font
    elif date.weekday()==5:
        cell.font = blue_font

    col += 1
    if col>7: col=1; row+=1
    day += 1

# --- 凡例 ---
legend_row = row + 2
ws.merge_cells(start_row=legend_row, start_column=1, end_row=legend_row, end_column=7)
#ws.cell(legend_row,1,"日直 = -1 シフト   当直 = -2/平日シフト   OC: On-call").alignment=center

# --- 保存 & DL ---
out_path="pretty_calendar.xlsx"
wb.save(out_path)
print("✔ 完了 – pretty_calendar.xlsx を生成しました。")
files.download(out_path)